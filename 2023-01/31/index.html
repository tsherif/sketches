<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collision Sketch</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            overflow-y: hidden;
        }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
(async () => {
    if (navigator.serviceWorker) {
        const registration = await navigator.serviceWorker.register("./sw.js")
        if (!navigator.serviceWorker.controller) {
            window.location.reload();
            return;
        }
    }

    if (!window.SharedArrayBuffer) {
        console.error("Sketch requires SharedArrayBuffer");
        return;
    }

    const canvas = document.getElementById("canvas");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const ctx = canvas.getContext("2d");

    const NUM_BALLS = 1000;
    const LAYER_NUM_ELEMENTS = NUM_BALLS * 5;
    const LAYER_BYTE_SIZE = LAYER_NUM_ELEMENTS * Float32Array.BYTES_PER_ELEMENT;
    const buffer = new SharedArrayBuffer(2 * LAYER_BYTE_SIZE);
    const ballsA = new Float32Array(buffer, 0, LAYER_NUM_ELEMENTS);
    const ballsB = new Float32Array(buffer, LAYER_BYTE_SIZE, LAYER_NUM_ELEMENTS);
    const colors = new Array(NUM_BALLS);

    for (let i = 0; i < NUM_BALLS; ++i) {
        const bi = i * 5;
        
        ballsA[bi]     = ballsB[bi]     = Math.random() * canvas.width;
        ballsA[bi + 1] = ballsB[bi + 1] = Math.random() * canvas.height;
        ballsA[bi + 2] = ballsB[bi + 2] = Math.random() * 2 - 1;
        ballsA[bi + 3] = ballsB[bi + 3] = Math.random() * 2 - 1;
        ballsA[bi + 4] = ballsB[bi + 4] = Math.random() * 9 + 1;

        colors[i] = `rgb(${Math.floor(Math.random() * 256)},${Math.floor(Math.random() * 256)},${Math.floor(Math.random() * 256)})`
    }

    const NUM_THREADS = 4;
    const BALLS_PER_THREAD = Math.ceil(NUM_BALLS / NUM_THREADS);
    let activeThreads = 0;

    const threads = new Array(NUM_THREADS).fill(null).map((_, i) => {
        const worker = new Worker("./sim-worker.js");
        worker.addEventListener("message", () => {
            --activeThreads;
            if (activeThreads === 0) {
                requestAnimationFrame(render);
            }
            
        });
        return {
            worker,
            start: i * BALLS_PER_THREAD,
            end: Math.min(NUM_BALLS, (i + 1) * BALLS_PER_THREAD),
            width: canvas.width,
            height: canvas.height,
            input: ballsA,
            output: ballsB,
            numBalls: NUM_BALLS
        };        
    });

    let inputLayer = ballsA;
    let outputLayer = ballsB;

    function render() {
        const { width, height } = canvas;

        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, width, height);

        for (let i = 0; i < NUM_BALLS; ++i) {
            const bi = i * 5;
            const x = outputLayer[bi];
            const y = outputLayer[bi + 1];
            const r = outputLayer[bi + 4];
            const c = colors[i];

            ctx.fillStyle = c;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, 2 * Math.PI);
            ctx.fill();
        }

        if (inputLayer === ballsA) {
            inputLayer = ballsB;
            outputLayer = ballsA;
        } else {
            inputLayer = ballsA;
            outputLayer = ballsB;
        }

        activeThreads = NUM_THREADS;
        threads.forEach(t => {
            const { start, end, worker } = t;
            const { width, height } = canvas;
            worker.postMessage({
                start,
                end,
                width,
                height,
                input: inputLayer,
                output: outputLayer,
                numBalls: NUM_BALLS
            });
        })
    }

    requestAnimationFrame(render);
})();
</script>
    
</body>
</html>